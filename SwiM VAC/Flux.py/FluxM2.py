import numpy as np
from matplotlib import pyplot as plt
from astropy.io import fits
import scipy.stats as st
import math
from scipy import signal
from astropy import wcs
import sys
from scipy import interpolate
import numpy as np
from scipy import interpolate
from numpy import inf
from astropy.stats import biweight_location
from astropy.stats import biweight_midvariance
from astropy.stats import sigma_clip

"""
This code generates the Sky-subtracted flux maps (in Nanomaggies) for the Swift UVOT filters.
The code uses outputs generated from Sextractor.py, Cutout.py and NSA_AC.py. These flux maps
will be used later on to generate the SwiM MAP files.
"""


#define paths
path_to_txt_file = '/Users/Nikhil/code/Newtext/' #Path to the text file that contains all MaNGA Ids for Swift filter
path_to_MaNGA_drpall = '/Users/Nikhil/Data/MaNGAPipe3D/Newmanga/' #Path to the MaNGA DRPALL file
path_to_NSA = '/Users/nikhil/Data/MaNGAPipe3D/Newmanga/' #Path to the NSA ALL file
path_to_MaNGA_hybrid_Maps = '/Volumes/Nikhil/MPL-7_Files/HYB10-GAU-MILESHC/' #Path to HYB10 MANGA MAPS
path_to_Swift_segmented_images = '/Volumes/Nikhil/SWIFT/New_SEG/' #Path to masked images generated by Sextractor.py
path_to_Swift_cutouts = '/Volumes/Nikhil/SWIFT/New_cutout/' #Path to Swift cutout images generated by Cutout.py
path_to_Swift_raw_data = '/Volumes/Nikhil/SWIFT/' #Path to raw Swift counts, error and exposure maps
path_to_store_Swift_Flux_maps = '/Volumes/Nikhil/SWIFT/New_flux/' #Path to store the generated flux images in fits format
path_to_aperture_corrections = '/Volumes/Nikhil/SWIFT/New_cat/' #Path to aperture correction fits file generated by NSA_AC.py




with open(path_to_txt_file + 'M2_ID.txt') as f:
   Line = [line.rstrip('\n') for line in open(path_to_txt_file + 'M2_ID.txt')]




for id in range (0,np.shape(Line)[0]):
  drpall = fits.open(path_to_MaNGA_drpall+'drpall-v2_3_1.fits')
  tbdata = drpall[1].data
  ind = np.where(tbdata['mangaid'] == Line[id])
  objectra = tbdata['objra'][ind][0]
  objectdec = tbdata['objdec'][ind][0]
  sloan = tbdata['nsa_iauname'][ind][0]
  pa = tbdata['nsa_elpetro_phi'][ind][0]
  axs = tbdata['nsa_elpetro_ba'][ind][0]
  nsa_all = fits.open(path_to_NSA+'nsa_v1_0_1.fits')
  nsa_data = nsa_all[1].data
  ind = np.where(nsa_data['IAUNAME'] == sloan)
  Relp = nsa_data['PETRO_THETA'][ind][0]
  apc = fits.open(path_to_aperture_corrections+'Aperture_Correction.fits')
  apc_data = apc[1].data
  ind_apc = np.where(apc_data['MangaID'] == Line[id])
  apc_m2 = apc[1].data['ApertureCorrect(w2,m2,w1)'][ind_apc][0][1]
  
  hdu = fits.open(path_to_Swift_segmented_images+str(Line[id])+'_UVM2_seg.fits')
  D_mask = np.clip(hdu[1].data,0,1)
  
  hdu = fits.open(path_to_Swift_cutouts+'UVM2_cutout_'+str(Line[id])+'.fits')
  CNTS = hdu[0].data
  EXP = hdu[2].data
  ERR = hdu[1].data
  w = wcs.WCS(hdu[0].header,naxis=2)
  pix1,pix2 = w.wcs_world2pix(objectra,objectdec,0)
  
  LZ = hdu[0].data.shape[0]
  Rx = [0]* (LZ)
  i=0
  while i<(LZ):
     Rx[i]=i
     i=i+1

  Ry = [Rx,]*(LZ)
  Ry.reverse()
  X= np.array(Ry)
  Y = np.transpose(Ry)

  rho = pa*(math.pi/180)
  thet = math.pi/2
  Yr = X*(np.cos(rho)) + Y*(np.sin(rho))
  Xr = (-1)*X*(np.sin(rho)) + Y*(np.cos(rho))
  pix2r = pix1*(np.cos(rho)) + pix2*(np.sin(rho))
  pix1r = (-1)*pix1*(np.sin(rho))+pix2*(np.cos(rho))

  li = [0] *(LZ)
  Li = [li,]*(LZ)
  Dist = np.array(Li)
  Dellip = np.array(Li)
  i=0
  while i<(LZ) :
       j=0
       while j<(LZ):
             Dist[i][j] = math.sqrt((X[i][j]-pix1)**2 + (Y[i][j]-pix2)**2)
             Dellip[i][j] = math.sqrt((Xr[i][j]-pix1r)**2 + ((Yr[i][j]-pix2r)**2)/(axs**2))
             j=j+1
       i=i+1
  BMSK1 = np.zeros(CNTS.shape)
  i=0
  while i < (LZ):
        j=0
        while j < (LZ):
              if Dellip[i,j] > 2*(Relp) and Dist[i,j] < 4*(Relp):
                 BMSK1[i,j]=1
              j=j+1
        i=i+1
  BMSK3 = np.zeros(CNTS.shape)
  i=0
  while i < (LZ):
        j=0
        while j < (LZ):
            if Dellip[i,j] < 2*(Relp):
               BMSK3[i,j]=1
            j=j+1
        i=i+1
        
  ALL_sky = np.ma.array(CNTS,mask=D_mask)
  Constant_index = np.where((EXP < EXP[int(pix1),int(pix2)]+5) & (EXP > EXP[int(pix1),int(pix2)]-5))
  Constant_mask = np.ones(CNTS.shape)
  Constant_mask[Constant_index] = 0
  Constant_sky = np.ma.array(ALL_sky,mask=Constant_mask)
  correct_sky = np.ma.array(Constant_sky,mask=1-BMSK1)
  correct_sky_clipped = sigma_clip(correct_sky,sigma=3,maxiters=10)
  sky_counts_initial = biweight_location(correct_sky_clipped)
  sky_counts_err_initial = np.sqrt(biweight_midvariance(correct_sky_clipped))
  if np.ma.is_masked(sky_counts_initial):
     sky_counts = biweight_location(sigma_clip(Constant_sky,sigma=3,maxiters=10))
     sky_counts_err = np.sqrt(biweight_midvariance(sigma_clip(Constant_sky,sigma=3,maxiters=10)))
  else:
     sky_counts = sky_counts_initial
     sky_counts_err = sky_counts_err_initial
     


  
  hdu = fits.open(path_to_Swift_raw_data+'CNTS/m'+str(Line[id])+'-m2d-cts.fits')
  hdr = hdu[0].header
  counts = hdu[0].data
  conv = hdu[0].header['FLAMC']
  cdel1 = hdu[0].header['CDELT1']
  cdel2 = hdu[0].header['CDELT2']
  crpix1 = hdu[0].header['CRPIX1']
  crpix2 = hdu[0].header['CRPIX2']
  cunit1 = hdu[0].header['CUNIT1']
  cunit2 = hdu[0].header['CUNIT2']
  rad = hdu[0].header['RADECSYS']
  crval1 = hdu[0].header['CRVAL1']
  crval2 = hdu[0].header['CRVAL2']
  filt = hdu[0].header['FILTER']
  simple = hdu[0].header['SIMPLE']
  bitpix = hdu[0].header['BITPIX']
  naxis = hdu[0].header['NAXIS']
  naxis1 = hdu[0].header['NAXIS1']
  naxis2 = hdu[0].header['NAXIS2']
  zp1 = hdu[0].header['ABMAGZP']
  
  #Calculating integrated magnitudes
  tau = EXP[int(pix1),int(pix2)]
  Sky_sub = CNTS - sky_counts
  masked_cnts= np.ma.array(Sky_sub,mask=1-BMSK3)
  masked_cnts[np.isnan(masked_cnts)] = 0
  masked_cnts = np.clip(masked_cnts,0,np.max(masked_cnts))
  masked_exp = np.ma.array(EXP,mask=1-BMSK3)
  masked_exp[np.isnan(masked_exp)] = 0
  masked_err = np.ma.array(ERR,mask=1-BMSK3)
  masked_err[np.isnan(masked_err)] = 0
  Ratio = masked_cnts/masked_exp
  Ratio[np.isnan(Ratio)] = 0
  masked_err_cnt_rate = np.sqrt(np.sum(masked_err**2))/tau
  SUMFLUX = np.sum(Ratio)
  TE = (2.5/2.302585093)*(masked_err_cnt_rate/(SUMFLUX))
  NEWFLUX = zp1 - 2.5*(np.log10(SUMFLUX))
  Nflux_NM = math.pow(10,9 - 0.4*NEWFLUX)*apc_m2
  Nfluxmag = 22.5 - 2.5*np.log10(Nflux_NM)


  hdu = fits.open(path_to_Swift_raw_data+'ERR/m'+Line[id]+'-m2d-cts-err.fits')
  err = hdu[0].data

  hdu = fits.open(path_to_Swift_raw_data+'EXP/m'+Line[id]+'-m2d-ex-dc.fits')
  exp = hdu[0].data

  Rate = (counts-sky_counts)/exp
  Fluxnmg1 = Rate*math.pow(10,9-zp1*0.4)
  MASK_M2 = np.zeros(np.shape(Fluxnmg1))
  MASK_M2[Fluxnmg1 == -inf]=1
  MASK_M2[Fluxnmg1== inf]=1
  MASK_M2[np.isnan(Fluxnmg1)]=1
  erate = err/exp
  enano1 = erate*math.pow(10,9-zp1*0.4)



  hdu0 = fits.PrimaryHDU(Fluxnmg1)
  hdu1 = fits.ImageHDU(enano1)
  hdu2 = fits.ImageHDU(counts-sky_counts)
  hdu3 = fits.ImageHDU(err)
  hdu4 = fits.ImageHDU(exp)
  hdu5 = fits.ImageHDU(MASK_M2)

  new_hdul = fits.HDUList([hdu0,hdu1,hdu2,hdu3,hdu4,hdu5])
  new_hdul.writeto(path_to_store_Swift_Flux_maps+str(Line[id])+'_UVM2_flx.fits')
    
  hdu = fits.open(path_to_store_Swift_Flux_maps+str(Line[id])+'_UVM2_flx.fits')
  hdr = hdu[0].header
  hdr['SIMPLE'] = simple
  hdr['BITPIX'] = bitpix
  hdr['NAXIS'] = naxis
  hdr['NAXIS1'] = naxis1
  hdr['NAXIS2'] = naxis2
  hdr['CTYPE1'] = 'RA---TAN'
  hdr['CTYPE2'] = 'DEC--TAN'
  hdr['CDELT1'] = cdel1
  hdr['CDELT2'] =  cdel2
  hdr['CRPIX1'] = crpix1
  hdr['CRPIX2'] = crpix2
  hdr['CUNIT1'] = cunit1
  hdr['CUNIT2'] = cunit2
  hdr['RADECSYS'] = rad
  hdr['CRVAL1'] = crval1
  hdr['CRVAL2'] = crval2
  hdr['FILTER'] = filt
  hdr['Flmbda'] = conv
  hdr['ABMAGZP'] = zp1
  hdr['SKYC'] = sky_counts
  hdr['ESKYC'] = sky_counts_err
  hdr['NUV(Mag) APC'] = Nfluxmag
  hdr['ENUV(Mag)'] = TE
  hdr['TYPE'] = 'NUV (Nanomaggies)'


  hdr1 = hdu[1].header
  hdr1['SIMPLE'] = simple
  hdr1['BITPIX'] = bitpix
  hdr1['NAXIS'] = naxis
  hdr1['NAXIS1'] = naxis1
  hdr1['NAXIS2'] = naxis2
  hdr1['CTYPE1'] = 'RA---TAN'
  hdr1['CTYPE2'] = 'DEC--TAN'
  hdr1['CDELT1'] = cdel1
  hdr1['CDELT2'] =  cdel2
  hdr1['CRPIX1'] = crpix1
  hdr1['CRPIX2'] = crpix2
  hdr1['CUNIT1'] = cunit1
  hdr1['CUNIT2'] = cunit2
  hdr1['RADECSYS'] = rad
  hdr1['CRVAL1'] = crval1
  hdr1['CRVAL2'] = crval2
  hdr1['FILTER'] = filt
  hdr1['Flmbda'] = conv
  hdr1['ABMAGZP'] = zp1
  hdr1['SKYC'] = sky_counts
  hdr1['ESKYC'] = sky_counts_err
  hdr1['TYPE'] = 'NUV error (Nanomaggies)'


  hdr2 = hdu[2].header
  hdr2['SIMPLE'] = simple
  hdr2['BITPIX'] = bitpix
  hdr2['NAXIS'] = naxis
  hdr2['NAXIS1'] = naxis1
  hdr2['NAXIS2'] = naxis2
  hdr2['CTYPE1'] = 'RA---TAN'
  hdr2['CTYPE2'] = 'DEC--TAN'
  hdr2['CDELT1'] = cdel1
  hdr2['CDELT2'] =  cdel2
  hdr2['CRPIX1'] = crpix1
  hdr2['CRPIX2'] = crpix2
  hdr2['CUNIT1'] = cunit1
  hdr2['CUNIT2'] = cunit2
  hdr2['RADECSYS'] = rad
  hdr2['CRVAL1'] = crval1
  hdr2['CRVAL2'] = crval2
  hdr2['FILTER'] = filt
  hdr2['Flmbda'] = conv
  hdr2['ABMAGZP'] = zp1
  hdr2['SKYC'] = sky_counts
  hdr2['ESKYC'] = sky_counts_err
  hdr2['TYPE'] = 'Sky Sub Counts'


  hdr3 = hdu[3].header
  hdr3['SIMPLE'] = simple
  hdr3['BITPIX'] = bitpix
  hdr3['NAXIS'] = naxis
  hdr3['NAXIS1'] = naxis1
  hdr3['NAXIS2'] = naxis2
  hdr3['CTYPE1'] = 'RA---TAN'
  hdr3['CTYPE2'] = 'DEC--TAN'
  hdr3['CDELT1'] = cdel1
  hdr3['CDELT2'] =  cdel2
  hdr3['CRPIX1'] = crpix1
  hdr3['CRPIX2'] = crpix2
  hdr3['CUNIT1'] = cunit1
  hdr3['CUNIT2'] = cunit2
  hdr3['RADECSYS'] = rad
  hdr3['CRVAL1'] = crval1
  hdr3['CRVAL2'] = crval2
  hdr3['FILTER'] = filt
  hdr3['Flmbda'] = conv
  hdr3['ABMAGZP'] = zp1
  hdr3['SKYC'] = sky_counts
  hdr3['ESKYC'] = sky_counts_err
  hdr3['TYPE'] = 'ErrCounts'


  hdr4 = hdu[4].header
  hdr4['SIMPLE'] = simple
  hdr4['BITPIX'] = bitpix
  hdr4['NAXIS'] = naxis
  hdr4['NAXIS1'] = naxis1
  hdr4['NAXIS2'] = naxis2
  hdr4['CTYPE1'] = 'RA---TAN'
  hdr4['CTYPE2'] = 'DEC--TAN'
  hdr4['CDELT1'] = cdel1
  hdr4['CDELT2'] =  cdel2
  hdr4['CRPIX1'] = crpix1
  hdr4['CRPIX2'] = crpix2
  hdr4['CUNIT1'] = cunit1
  hdr4['CUNIT2'] = cunit2
  hdr4['RADECSYS'] = rad
  hdr4['CRVAL1'] = crval1
  hdr4['CRVAL2'] = crval2
  hdr4['FILTER'] = filt
  hdr4['Flmbda'] = conv
  hdr4['ABMAGZP'] = zp1
  hdr4['SKYC'] = sky_counts
  hdr4['ESKYC'] = sky_counts_err
  hdr4['TYPE'] = 'Exposure'


  
  hdr5 = hdu[5].header
  hdr5['SIMPLE'] = simple
  hdr5['BITPIX'] = bitpix
  hdr5['NAXIS'] = naxis
  hdr5['NAXIS1'] = naxis1
  hdr5['NAXIS2'] = naxis2
  hdr5['CTYPE1'] = 'RA---TAN'
  hdr5['CTYPE2'] = 'DEC--TAN'
  hdr5['CDELT1'] = cdel1
  hdr5['CDELT2'] =  cdel2
  hdr5['CRPIX1'] = crpix1
  hdr5['CRPIX2'] = crpix2
  hdr5['CUNIT1'] = cunit1
  hdr5['CUNIT2'] = cunit2
  hdr5['RADECSYS'] = rad
  hdr5['CRVAL1'] = crval1
  hdr5['CRVAL2'] = crval2
  hdr5['FILTER'] = filt
  hdr5['Flmbda'] = conv
  hdr5['ABMAGZP'] = zp1
  hdr5['SKYC'] = sky_counts
  hdr5['ESKYC'] = sky_counts_err
  hdr5['TYPE'] = 'MASK'


  hdu.writeto(path_to_store_Swift_Flux_maps+str(Line[id])+'_UVM2_flx.fits',overwrite=True)

